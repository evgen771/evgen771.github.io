---
layout: post
title: ImageMagick. Команды 1.
category: Magick
---

#### Команда отображения

Начнем с команды, упомянутой Скоттом: **display** . Предположим, у вас есть каталог с множеством изображений, которые вы хотите просмотреть. Запустите **отображение** с помощью следующей команды:

```bash
cd Pictures
display *.JPG
```

При этом ваши файлы JPG будут загружаться последовательно в буквенно-цифровом порядке, по одному в простом окне. Щелчок левой кнопкой мыши по изображению вызывает простое автономное меню (единственная функция графического интерфейса, которую вы увидите в ImageMagick).

![меню дисплея](https://opensource.com/sites/default/files/u128651/display_menu.png)

Вот что вы найдете в **меню дисплея** :

- **Файл** содержит параметры _«Открыть», «Следующий», «Бывший», «Выбрать», «Сохранить», «Печать», «Удалить», «Новый», «Визуальный каталог»_ и _«Выход»_ . _Select_ выбирает для отображения конкретный файл изображения, _Visual Directory_ показывает все файлы (а не только изображения) в текущем рабочем каталоге. Если вы хотите прокрутить все выбранные изображения, вы можете использовать _Next_ и _Former_ , но проще использовать их сочетания клавиш (пробел для следующего изображения и Backspace для предыдущего).

- **Редактирование** предлагает _«Отменить», «Повторить», «Вырезать», «Копировать»_ и _«Вставить»_ , которые являются лишь вспомогательными командами для более конкретного процесса редактирования. _Отмена_ особенно полезна, когда вы экспериментируете с различными изменениями, чтобы увидеть, что они делают.

- **Просмотр** имеет _половинный размер, исходный размер, двойной размер, изменение размера, применение, обновление_ и _восстановление_ . Они в основном не требуют пояснений, и, если вы не сохраните изображение после применения одного из них, файл изображения не изменится. _При изменении размера_ открывается диалоговое окно для указания конкретного размера в пикселях, с ограниченными размерами или без них, или в процентах. Я не уверен, что _делает Apply_ .

- **Трансформация** показывает _обрезку, обрезку, переворот, переворот, поворот вправо, поворот влево, поворот, сдвиг, перекат_ и _обрезку краев_ . _Chop_ использует операцию щелчка и перетаскивания, чтобы вырезать вертикальную или горизонтальную часть изображения, склеивая края вместе. Лучший способ узнать, как работают эти функции, — поиграть с ними, а не читать о них.

- **Улучшение** обеспечивает _оттенок, насыщенность, яркость, гамму, яркость, тусклый, растягивание контраста, сигмоидальный контраст, нормализацию, выравнивание, отрицание, оттенки серого, отображение_ и _квантование_ . Это операции по манипулированию цветом и настройке яркости и контрастности.

- **Эффекты** включают _«Устранение пятен», «Тиснение», «Уменьшение шума», «Добавление шума», «Резкость», «Размытие», «Порог», «Обнаружение краев», «Распространение», «Затенение», «Поднятие»_ и _«Сегмент»_ . Это довольно стандартные эффекты редактирования изображений.

- **F/X** Параметры _— «Соляризация», «Тон сепии», «Вихрь», «Имплод», «Виньетка», «Волна», «Масляная краска_ » и _«Рисование углем»_ — также очень распространенные эффекты в графических редакторах.

- **Редактирование изображения** включает в себя _«Аннотацию», «Рисование», «Цвет», «Матовый», «Композитный», «Добавить рамку», «Добавить рамку», «Комментарий», «Запустить_ » и _«Область интереса»_ . _Запуск_ откроет текущее изображение в GIMP (по крайней мере, в моей Fedora). _Область интереса_ позволяет вам выбрать область для редактирования; нажмите Esc, чтобы отменить выбор региона.

- **«Разное»** предлагает _информацию об изображении, масштабирование изображения, предварительный просмотр, показ гистограммы, отображение подложки, фон, слайд-шоу_ и _настройки_ . _Предварительный просмотр_ кажется интересным, но я изо всех сил пытался заставить его работать.

- **В справке** отображаются _«Обзор», «Просмотр документации»_ и _«Об отображении»_ . _Обзор_ дает много базовой информации об отображении и включает в себя большое количество встроенных эквивалентов клавиатуры для различных команд и операций. В моей Fedora _функция «Просмотр документации»_ ни к чему не привела.

Хотя **графический интерфейс display** предоставляет достаточно компетентный редактор изображений, ImageMagick также предоставляет 89 параметров командной строки, многие из которых соответствуют пунктам меню выше. Например, если я показываю каталог цифровых изображений, размер которых превышает размер моего экрана, вместо того, чтобы изменять их размер по отдельности после того, как они появятся на моем экране, я могу указать:

```bash
     display -resize 50% *.JPG
```

Многие операции в приведенных выше меню также можно выполнить, добавив параметр в командную строку. Но есть и другие, недоступные в меню, в том числе **‑monochrome** , который преобразует изображение в черно-белое (не в оттенках серого), и **‑colors** , где вы можете указать, сколько цветов использовать в изображении. Например, попробуйте следующее:

```bash
     display -resize 50% -monochrome *.JPG
```

```bash
     display -resize 50% -colors 8 *.JPG
```

Эти операции создают интересные изображения. Попробуйте улучшить цвета или внести другие изменения после уменьшения цвета. Помните: если вы не сохраните и не перезапишете их, исходные файлы останутся неизменными.

#### Команда конвертации

Команда `convert` устарела в `Img7`(`ImageMagick7`), используйте `magick` вместо `convert` или `magick convert`.

Команда **Convert** имеет 237 опций (да, 237), которые предоставляют широкий спектр возможностей, которые вы можете сделать (некоторые из которых может выполнять и display). Я расскажу лишь о некоторых из них, в основном придерживаясь манипуляций с изображениями. Две простые вещи, которые вы можете сделать с помощью **Convert** :

```bash
     convert DSC_0001.JPG dsc0001.png
```

```bash
     convert *.bmp *.png
```

Первая команда преобразует один файл (DSC_0001) из формата JPG в PNG без изменения оригинала. Второй проделал бы эту операцию со всеми изображениями BMP в каталоге.

Если вы хотите увидеть форматы, с которыми может работать ImageMagick, введите:

```bash
     identify -list format
```

Давайте рассмотрим несколько интересных способов использования **команды Convert** для управления изображениями. Вот общий формат этой команды:

```bash
     convert inputfilename [options] outputfilename
```

У вас может быть несколько вариантов, и они выполняются в том порядке, в котором они расположены, слева направо.

Вот пара простых вариантов:

```bash
     convert monochrome_source.jpg -monochrome monochrome_example.jpg
```

![монохромный пример](https://opensource.com/sites/default/files/u128651/monochrome_demo.jpg)

```bash
     convert DSC_0008.jpg -charcoal 1.2 charcoal_example.jpg
```

![пример угля](https://opensource.com/sites/default/files/u128651/charcoal_demo.jpg)


Опция **‑monochrome** не имеет связанной настройки, но **для переменной ‑charcoal** требуется связанный коэффициент. По моему опыту, это число должно быть небольшим (даже меньше 1), чтобы получить что-то похожее на рисунок углем, иначе вы получите довольно тяжелые черные пятна. Несмотря на это, резкие края изображения довольно четкие, в отличие от рисунка углем.

Теперь давайте посмотрим на это:

```bash
     convert DSC_0032.JPG -edge 3 edge_demo.jpg
```

```bash
     convert DSC_0032.JPG -colors 4 reduced4_demo.jpg
```

```bash
     convert DSC_0032.JPG -colors 4 -edge 3 reduced+edge_demo.jpg
```

![Пример краев и уменьшенных цветов](https://opensource.com/sites/default/files/u128651/reduced_demo.jpg)


Исходное изображение находится вверху слева. В первой команде я применил **параметр ‑edge** со значением 3 (см. верхнее правое изображение) — все, что меньше этого, на мой вкус, было слишком тонким. Во второй команде (нижнее левое изображение) мы уменьшили количество цветов до четырех, что не сильно отличается от оригинала. Но посмотрите, что произойдет, если мы объединим эти две команды в третьей команде (изображение в правом нижнем углу)! Возможно, это немного резковато, но кто бы мог ожидать такого результата от исходного изображения или любого другого варианта по отдельности?

Команда **‑canny** преподнесла еще один сюрприз. Это еще один вид детектора границ, называемый «многоэтапным алгоритмом». Использование **только ‑canny** дает в основном черное изображение и несколько белых линий. Я последовал за этим с помощью **команды ‑negate** :

```bash
     convert DSC_0049.jpg -canny 0x1 -negate canny_egret.jpg
     convert DSC_0023.jpg -canny 0x1 -negate canny_ship.jpg
```

![хитрая демонстрация](https://opensource.com/sites/default/files/u128651/canny_demos.jpg)


Это немного минималистично, но мне кажется, что это напоминает рисунок пером, что довольно заметно отличается от оригинальных фотографий. Это работает не со всеми изображениями; как правило, лучше всего он работает с изображениями с резкими линиями. Элементы, находящиеся вне фокуса, скорее всего, исчезнут; обратите внимание, что фоновая песчаная коса на изображении цапли не видна, потому что она размыта. Также обратите внимание на изображение корабля: хотя большинство краев видны очень хорошо, без цветов мы теряем целостность изображения, так что, возможно, это может стать основой для некоторой цифровой окраски или даже раскраски после печати.

## Команда монтажа

Наконец, я хочу поговорить о **команде монтажа** . Выше я уже показывал примеры, где объединял отдельные изображения в композиции.

Вот как я создал пример с углем (обратите внимание, что все это будет в одной строке):

```bash
     montage -label %f DSC_0008.jpg charcoal_example.jpg -geometry +10+10
           -resize 25% -shadow -title 'charcoal demo' charcoal_demo.jpg
```

Опция **-label** помечает каждое изображение именем файла ( **%f** ) внизу. Без **опции ‑geometry** все изображения будут иметь размер миниатюр (ширина 120 пикселей), а **+10+10** управляет размером границы. Затем я изменил размер всей финальной композиции ( **-resize 25%** ), добавил тень (без настроек, так что это значение по умолчанию) и, наконец, создал заголовок **для** монтажа.

Вы можете поместить все имена изображений в конце, при этом последнее изображение будет называться файлом, в котором сохраняется монтаж. Это может быть полезно для создания псевдонима для команды и всех ее параметров, после чего я могу просто ввести псевдоним, а затем соответствующие имена файлов. Я делал это время от времени, чтобы сократить набор текста, необходимый для создания серии монтажей.

В **ярких** примерах у меня в монтаже было четыре изображения. Я добавил **параметр ‑tile** , а именно **‑tile 2x** , который создавал монтаж двух столбцов. Я мог бы указать **матрицу** , **‑tile 2x2** или **‑tile x2** , чтобы получить тот же результат.

Об ImageMagick можно узнать гораздо больше, поэтому я планирую написать о нем больше, возможно, даже об использовании [Perl](https://opensource.com/sitewide-search?search_api_views_fulltext=perl) для написания сценариев команд ImageMagick. ImageMagick имеет обширную [документацию](https://imagemagick.org/script/index.php) , хотя на сайте мало примеров или результатов, и я думаю, что лучший способ учиться — экспериментировать и изменять различные настройки и параметры.## Команда отображения

Начнем с команды, упомянутой Скоттом: **display** . Предположим, у вас есть каталог с множеством изображений, которые вы хотите просмотреть. Запустите **отображение** с помощью следующей команды:

```bash
cd Pictures
display *.JPG
```

При этом ваши файлы JPG будут загружаться последовательно в буквенно-цифровом порядке, по одному в простом окне. Щелчок левой кнопкой мыши по изображению вызывает простое автономное меню (единственная функция графического интерфейса, которую вы увидите в ImageMagick).

![меню дисплея](https://opensource.com/sites/default/files/u128651/display_menu.png)


Вот что вы найдете в **меню дисплея** :

- **Файл** содержит параметры _«Открыть», «Следующий», «Бывший», «Выбрать», «Сохранить», «Печать», «Удалить», «Новый», «Визуальный каталог»_ и _«Выход»_ . _Select_ выбирает для отображения конкретный файл изображения, _Visual Directory_ показывает все файлы (а не только изображения) в текущем рабочем каталоге. Если вы хотите прокрутить все выбранные изображения, вы можете использовать _Next_ и _Former_ , но проще использовать их сочетания клавиш (пробел для следующего изображения и Backspace для предыдущего).
- **Редактирование** предлагает _«Отменить», «Повторить», «Вырезать», «Копировать»_ и _«Вставить»_ , которые являются лишь вспомогательными командами для более конкретного процесса редактирования. _Отмена_ особенно полезна, когда вы экспериментируете с различными изменениями, чтобы увидеть, что они делают.
- **Просмотр** имеет _половинный размер, исходный размер, двойной размер, изменение размера, применение, обновление_ и _восстановление_ . Они в основном не требуют пояснений, и, если вы не сохраните изображение после применения одного из них, файл изображения не изменится. _При изменении размера_ открывается диалоговое окно для указания конкретного размера в пикселях, с ограниченными размерами или без них, или в процентах. Я не уверен, что _делает Apply_ .
- **Трансформация** показывает _обрезку, обрезку, переворот, переворот, поворот вправо, поворот влево, поворот, сдвиг, перекат_ и _обрезку краев_ . _Chop_ использует операцию щелчка и перетаскивания, чтобы вырезать вертикальную или горизонтальную часть изображения, склеивая края вместе. Лучший способ узнать, как работают эти функции, — поиграть с ними, а не читать о них.
- **Улучшение** обеспечивает _оттенок, насыщенность, яркость, гамму, яркость, тусклый, растягивание контраста, сигмоидальный контраст, нормализацию, выравнивание, отрицание, оттенки серого, отображение_ и _квантование_ . Это операции по манипулированию цветом и настройке яркости и контрастности.
- **Эффекты** включают _«Устранение пятен», «Тиснение», «Уменьшение шума», «Добавление шума», «Резкость», «Размытие», «Порог», «Обнаружение краев», «Распространение», «Затенение», «Поднятие»_ и _«Сегмент»_ . Это довольно стандартные эффекты редактирования изображений.
- **F/X** Параметры _— «Соляризация», «Тон сепии», «Вихрь», «Имплод», «Виньетка», «Волна», «Масляная краска_ » и _«Рисование углем»_ — также очень распространенные эффекты в графических редакторах.
- **Редактирование изображения** включает в себя _«Аннотацию», «Рисование», «Цвет», «Матовый», «Композитный», «Добавить рамку», «Добавить рамку», «Комментарий», «Запустить_ » и _«Область интереса»_ . _Запуск_ откроет текущее изображение в GIMP (по крайней мере, в моей Fedora). _Область интереса_ позволяет вам выбрать область для редактирования; нажмите Esc, чтобы отменить выбор региона.
- **«Разное»** предлагает _информацию об изображении, масштабирование изображения, предварительный просмотр, показ гистограммы, отображение подложки, фон, слайд-шоу_ и _настройки_ . _Предварительный просмотр_ кажется интересным, но я изо всех сил пытался заставить его работать.
- **В справке** отображаются _«Обзор», «Просмотр документации»_ и _«Об отображении»_ . _Обзор_ дает много базовой информации об отображении и включает в себя большое количество встроенных эквивалентов клавиатуры для различных команд и операций. В моей Fedora _функция «Просмотр документации»_ ни к чему не привела.

Хотя **графический интерфейс display** предоставляет достаточно компетентный редактор изображений, ImageMagick также предоставляет 89 параметров командной строки, многие из которых соответствуют пунктам меню выше. Например, если я показываю каталог цифровых изображений, размер которых превышает размер моего экрана, вместо того, чтобы изменять их размер по отдельности после того, как они появятся на моем экране, я могу указать:

```bash
     display -resize 50% *.JPG
```

Многие операции в приведенных выше меню также можно выполнить, добавив параметр в командную строку. Но есть и другие, недоступные в меню, в том числе **‑monochrome** , который преобразует изображение в черно-белое (не в оттенках серого), и **‑colors** , где вы можете указать, сколько цветов использовать в изображении. Например, попробуйте следующее:

```bash
     display -resize 50% -monochrome *.JPG
```

```bash
     display -resize 50% -colors 8 *.JPG
```

Эти операции создают интересные изображения. Попробуйте улучшить цвета или внести другие изменения после уменьшения цвета. Помните: если вы не сохраните и не перезапишете их, исходные файлы останутся неизменными.

## Команда конвертации

Команда **Convert** имеет 237 опций (да, 237), которые предоставляют широкий спектр возможностей, которые вы можете сделать (некоторые из которых может выполнять и display). Я расскажу лишь о некоторых из них, в основном придерживаясь манипуляций с изображениями. Две простые вещи, которые вы можете сделать с помощью **Convert** :

```bash
     convert DSC_0001.JPG dsc0001.png
```

```bash
     convert *.bmp *.png
```

Первая команда преобразует один файл (DSC_0001) из формата JPG в PNG без изменения оригинала. Второй проделал бы эту операцию со всеми изображениями BMP в каталоге.

Если вы хотите увидеть форматы, с которыми может работать ImageMagick, введите:

```bash
     identify -list format
```

Давайте рассмотрим несколько интересных способов использования **команды Convert** для управления изображениями. Вот общий формат этой команды:

```bash
     convert inputfilename [options] outputfilename
```

У вас может быть несколько вариантов, и они выполняются в том порядке, в котором они расположены, слева направо.

Вот пара простых вариантов:

```bash
     convert monochrome_source.jpg -monochrome monochrome_example.jpg
```

![монохромный пример](https://opensource.com/sites/default/files/u128651/monochrome_demo.jpg)


```bash
     convert DSC_0008.jpg -charcoal 1.2 charcoal_example.jpg
```

![пример угля](https://opensource.com/sites/default/files/u128651/charcoal_demo.jpg)


Опция **‑monochrome** не имеет связанной настройки, но **для переменной ‑charcoal** требуется связанный коэффициент. По моему опыту, это число должно быть небольшим (даже меньше 1), чтобы получить что-то похожее на рисунок углем, иначе вы получите довольно тяжелые черные пятна. Несмотря на это, резкие края изображения довольно четкие, в отличие от рисунка углем.

Теперь давайте посмотрим на это:

```bash
     convert DSC_0032.JPG -edge 3 edge_demo.jpg
```

```bash
     convert DSC_0032.JPG -colors 4 reduced4_demo.jpg
```

```bash
     convert DSC_0032.JPG -colors 4 -edge 3 reduced+edge_demo.jpg
```

![Пример краев и уменьшенных цветов](https://opensource.com/sites/default/files/u128651/reduced_demo.jpg)


Исходное изображение находится вверху слева. В первой команде я применил **параметр ‑edge** со значением 3 (см. верхнее правое изображение) — все, что меньше этого, на мой вкус, было слишком тонким. Во второй команде (нижнее левое изображение) мы уменьшили количество цветов до четырех, что не сильно отличается от оригинала. Но посмотрите, что произойдет, если мы объединим эти две команды в третьей команде (изображение в правом нижнем углу)! Возможно, это немного резковато, но кто бы мог ожидать такого результата от исходного изображения или любого другого варианта по отдельности?

Команда **‑canny** преподнесла еще один сюрприз. Это еще один вид детектора границ, называемый «многоэтапным алгоритмом». Использование **только ‑canny** дает в основном черное изображение и несколько белых линий. Я последовал за этим с помощью **команды ‑negate** :

```bash
     convert DSC_0049.jpg -canny 0x1 -negate canny_egret.jpg
     convert DSC_0023.jpg -canny 0x1 -negate canny_ship.jpg
```

![хитрая демонстрация](https://opensource.com/sites/default/files/u128651/canny_demos.jpg)


Это немного минималистично, но мне кажется, что это напоминает рисунок пером, что довольно заметно отличается от оригинальных фотографий. Это работает не со всеми изображениями; как правило, лучше всего он работает с изображениями с резкими линиями. Элементы, находящиеся вне фокуса, скорее всего, исчезнут; обратите внимание, что фоновая песчаная коса на изображении цапли не видна, потому что она размыта. Также обратите внимание на изображение корабля: хотя большинство краев видны очень хорошо, без цветов мы теряем целостность изображения, так что, возможно, это может стать основой для некоторой цифровой окраски или даже раскраски после печати.

## Команда монтажа

Наконец, я хочу поговорить о **команде монтажа** . Выше я уже показывал примеры, где объединял отдельные изображения в композиции.

Вот как я создал пример с углем (обратите внимание, что все это будет в одной строке):

```bash
     montage -label %f DSC_0008.jpg charcoal_example.jpg -geometry +10+10
           -resize 25% -shadow -title 'charcoal demo' charcoal_demo.jpg
```

Опция **-label** помечает каждое изображение именем файла ( **%f** ) внизу. Без **опции ‑geometry** все изображения будут иметь размер миниатюр (ширина 120 пикселей), а **+10+10** управляет размером границы. Затем я изменил размер всей финальной композиции ( **-resize 25%** ), добавил тень (без настроек, так что это значение по умолчанию) и, наконец, создал заголовок **для** монтажа.

Вы можете поместить все имена изображений в конце, при этом последнее изображение будет называться файлом, в котором сохраняется монтаж. Это может быть полезно для создания псевдонима для команды и всех ее параметров, после чего я могу просто ввести псевдоним, а затем соответствующие имена файлов. Я делал это время от времени, чтобы сократить набор текста, необходимый для создания серии монтажей.

В **ярких** примерах у меня в монтаже было четыре изображения. Я добавил **параметр ‑tile** , а именно **‑tile 2x** , который создавал монтаж двух столбцов. Я мог бы указать **матрицу** , **‑tile 2x2** или **‑tile x2** , чтобы получить тот же результат.

Об ImageMagick можно узнать гораздо больше, поэтому я планирую написать о нем больше, возможно, даже об использовании [Perl](https://opensource.com/sitewide-search?search_api_views_fulltext=perl) для написания сценариев команд ImageMagick. ImageMagick имеет обширную [документацию](https://imagemagick.org/script/index.php) , хотя на сайте мало примеров или результатов, и я думаю, что лучший способ учиться — экспериментировать и изменять различные настройки и параметры.
