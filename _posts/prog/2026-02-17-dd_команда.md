---
layout: post
title: dd. Подробное руководство.
categories: Программы
---


`dd` — мощная низкоуровневая утилита в UNIX‑подобных системах для **побайтового копирования данных**. 

Позволяет работать с файлами, устройствами и разделами на уровне блоков, что делает её незаменимой для:

* создания образов дисков и разделов;
* клонирования накопителей;
* резервного копирования MBR;
* заполнения носителей нулями/случайными данными;
* создания зашифрованных контейнеров;
* тестирования производительности дисков.

### Базовый синтаксис

```bash
dd if=<источник> of=<назначение> [опции]
```

**Ключевые параметры:**

* `if=` — источник данных (файл, устройство, раздел). 
* `of=` — место назначения (файл, устройство). 
* `bs=` — размер блока для чтения/записи (в байтах). 
* `count=` — количество блоков для копирования. 
* `conv=` — фильтры для преобразования данных. 
* `status=` — уровень вывода информации. 
* `skip=` — пропустить блоки в источнике перед копированием. 
* `seek=` — пропустить блоки в назначении перед записью.

**Важно!** 

* Команда **не запрашивает подтверждение** перед перезаписью. 
* Ошибка в пути может привести к **необратимой потере данных**. 
* По умолчанию `dd` использует блок размером **512 байт**.

### Основные опции

1. **`bs=N`** 

  * Размер блока (например, `bs=4M` — 4 МБ). Увеличивает скорость копирования. 
  * *Рекомендуемые значения:* `512K`, `1M`, `4M`.

2. **`count=N`** 

   Копирует ровно `N` блоков (размер блока задаётся через `bs`).

3. **`conv=noerror,sync`** 

   * `noerror` — продолжать копирование при ошибках чтения. 
   * `sync` — дополнять неполные блоки нулями.

4. **`status=progress`** 

   Показывает прогресс копирования в реальном времени.

5. **`skip=N`** 

   Пропускает `N` блоков в источнике перед началом копирования.

6. **`seek=N`** 

   Пропускает `N` блоков в назначении перед записью.


### Практические примеры

#### 1. Создание образа диска

```bash
dd if=/dev/sda of=disk_image.img bs=4M status=progress
```
* `if=/dev/sda` — копируем с диска `/dev/sda`. 
* `of=disk_image.img` — сохраняем в файл `disk_image.img`. 
* `bs=4M` — блок 4 МБ для ускорения. 
* `status=progress` — отображать прогресс.

#### 2. Восстановление диска из образа

```bash
dd if=disk_image.img of=/dev/sdb bs=4M status=progress
```

* Восстанавливает образ `disk_image.img` на диск `/dev/sdb`.

#### 3. Резервное копирование MBR (первые 512 байт)

```bash
dd if=/dev/sda of=mbr_backup.bin bs=512 count=1
```

* Сохраняет MBR диска `/dev/sda` в файл `mbr_backup.bin`.


#### 4. Восстановление MBR

```bash
dd if=mbr_backup.bin of=/dev/sda bs=512 count=1
```

* Записывает резервную копию MBR обратно на диск `/dev/sda`.

#### 5. Клонирование диска
```bash
dd if=/dev/sda of=/dev/sdb bs=4M conv=noerror,sync status=progress
```

* Полностью копирует `/dev/sda` на `/dev/sdb`. 
* `conv=noerror,sync` — продолжает при ошибках, заполняет пропуски нулями.

#### 6. Создание загрузочного USB из ISO

```bash
sudo dd if=ubuntu.iso of=/dev/sdX bs=4M status=progress
```

* Записывает образ `ubuntu.iso` на устройство `/dev/sdX` (замените `sdX` на реальный идентификатор USB).

#### 7. Очистка диска нулями

```bash
dd if=/dev/zero of=/dev/sdX bs=4M status=progress
```

* Заполняет диск `/dev/sdX` нулями (удаляет все данные).

#### 8. Создание файла заданного размера

```bash
dd if=/dev/zero of=file.img bs=1M count=1000
```

* Создаёт файл `file.img` размером 1 ГБ (1000 × 1 МБ).

#### 9. Копирование части диска

```bash
dd if=/dev/sdX of=partition.img bs=4M skip=10 count=100
```

* Пропускает 10 блоков (40 МБ) и копирует следующие 100 блоков (400 МБ).

#### 10. Тестирование скорости чтения диска

```bash
dd if=/dev/sda of=/dev/null bs=1M count=1000 status=progress
```

* Измеряет скорость чтения с диска `/dev/sda` (данные отправляются в `/dev/null`).

### Безопасность и предостережения

1. **Двойная проверка путей** 

   Убедитесь, что `if=` и `of=` указаны верно. Ошибка может уничтожить данные.

2. **Резервное копирование** 

   Перед операциями с дисками сделайте бэкап важных данных.


3. **Использование `status=progress`** 

   Всегда добавляйте `status=progress`, чтобы отслеживать процесс.

4. **Работа с правами суперпользователя** 

   Для доступа к устройствам часто требуется `sudo`.

5. **Осторожность с `conv=noerror`** 

   Может привести к копированию повреждённых данных. Используйте только при необходимости.

### Продвинутые сценарии

#### Создание зашифрованного контейнера

```bash
# 1. Создаём файл размером 1 ГБ
dd if=/dev/zero of=crypto.img bs=1M count=1000
# 2. Ассоциируем с loop‑устройством (шифрование blowfish)
sudo losetup -e blowfish /dev/loop0 crypto.img
# 3. Создаём файловую систему
sudo mkfs.ext4 /dev/loop0
# 4. Монтируем
sudo mount /dev/loop0 /mnt/crypto
```

#### Восстановление данных с повреждённого диска

```bash
dd if=/dev/cdrom of=cd_image.iso bs=2048 conv=noerror,sync
```

* `bs=2048` — стандартный размер блока для CD/DVD. 
* `conv=noerror,sync` — пропускает ошибки, заполняет пропуски.

### Советы по оптимизации

1. **Выбор размера блока (`bs`)** 

   * Для HDD: `bs=4M`. 
   * Для SSD: `bs=1M`. 
   * Для оптических дисков: `bs=2048`.

2. **Использование `iflag=fullblock`** 

   Гарантирует чтение полных блоков: 
   
   ```bash
   dd if=/dev/sda of=image.img bs=4M iflag=fullblock
   ```

3. **Отключение кэширования (`oflag=direct`)** 

   Для прямого доступа к устройству: 
   
   ```bash
   dd if=image.img of=/dev/sdb bs=4M oflag=direct
   ```

### Заключение

`dd` — универсальный инструмент для низкоуровневых операций с данными. Его ключевые преимущества:

* точность копирования (байт‑в‑байт);
* гибкость настроек (блоки, фильтры, пропуск ошибок);
* работа с любыми устройствами (диски, разделы, образы).

**Критично:** 

* Всегда проверяйте параметры `if` и `of`. 
* Используйте `status=progress` для контроля. 
* Делайте бэкапы перед опасными операциями.

Для сложных задач (например, инкрементного бэкапа) рассмотрите альтернативы: `rsync`, `tar`, `dump`.
